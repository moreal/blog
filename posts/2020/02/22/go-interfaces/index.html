<!doctype html><html lang=en-us><head><title>How works Go interface? // Moreal</title><meta charset=utf-8><meta name=generator content="Hugo 0.59.1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="모래알"><meta name=description content><link rel=stylesheet href=https://blog.moreal.kr/css/main.min.1d410c4f3be87745e986ad5991a8e587e522eb70056c9668a64694092dc27997.css><meta name=twitter:card content="summary"><meta name=twitter:title content="How works Go interface?"><meta name=twitter:description content="의문 utilForever/falcon의 간단한 프로토타입을 만들면서 CompilerProxy 인터페이스를 구현하는 GccCompilerProxy 구조체를 작성하였습니다.
// compiler_proxy_test.go var compilerProxy *CompilerProxy = NewGccCompilerProxy() // compiler_proxy.go type CompilerProxy interface { AddLibrary() IncludeDirectory() Compile(srcPath, outPath string) } type GccCompilerProxy struct {} func (cp *GccCompilerProxy) AddLibrary() {} func (cp *GccCompilerProxy) IncludeDirectory() {} func (cp *GccCompilerProxy) Compile(srcPath, outPath string) {} func NewGccCompilerProxy() *GccCompilerProxy { return &amp;GccCompilerProxy{} }  당연히 *interface = *struct 대입이 될 거라 생각했지만 컴파일러는 제게 에러 메시지 만을 남겼습니다."><meta property="og:title" content="How works Go interface?"><meta property="og:description" content="의문 utilForever/falcon의 간단한 프로토타입을 만들면서 CompilerProxy 인터페이스를 구현하는 GccCompilerProxy 구조체를 작성하였습니다.
// compiler_proxy_test.go var compilerProxy *CompilerProxy = NewGccCompilerProxy() // compiler_proxy.go type CompilerProxy interface { AddLibrary() IncludeDirectory() Compile(srcPath, outPath string) } type GccCompilerProxy struct {} func (cp *GccCompilerProxy) AddLibrary() {} func (cp *GccCompilerProxy) IncludeDirectory() {} func (cp *GccCompilerProxy) Compile(srcPath, outPath string) {} func NewGccCompilerProxy() *GccCompilerProxy { return &amp;GccCompilerProxy{} }  당연히 *interface = *struct 대입이 될 거라 생각했지만 컴파일러는 제게 에러 메시지 만을 남겼습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://blog.moreal.kr/posts/2020/02/22/go-interfaces/"><meta property="article:published_time" content="2020-02-22T22:24:39+09:00"><meta property="article:modified_time" content="2020-02-22T22:24:39+09:00"></head><body><header class=app-header><a href=https://blog.moreal.kr/><img class=app-header-avatar src=/avatar.jpg alt=모래알></a><h1>Moreal</h1><p>모래성 쌓듯.</p><div class=app-header-social><a target=_blank href=https://github.com/moreal rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0 0 20 4.77 5.07 5.07.0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38.0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 0 0 5 4.77a5.44 5.44.0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 0 0 9 18.13V22"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>How works Go interface?</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Feb 22, 2020</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>3 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83.0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><a class=tag href=https://blog.moreal.kr/tags/go-internals/>go-internals</a></div></div></header><div class=post-content><h2 id=의문>의문</h2><p><code>utilForever/falcon</code>의 간단한 프로토타입을 만들면서 <code>CompilerProxy</code> 인터페이스를 구현하는 <code>GccCompilerProxy</code> 구조체를 작성하였습니다.</p><pre><code class=language-golang>// compiler_proxy_test.go
var compilerProxy *CompilerProxy = NewGccCompilerProxy()

// compiler_proxy.go
type CompilerProxy interface {
	AddLibrary()
	IncludeDirectory()
	Compile(srcPath, outPath string)
}

type GccCompilerProxy struct {}

func (cp *GccCompilerProxy) AddLibrary() {}

func (cp *GccCompilerProxy) IncludeDirectory() {}

func (cp *GccCompilerProxy) Compile(srcPath, outPath string) {}

func NewGccCompilerProxy() *GccCompilerProxy {
	return &amp;GccCompilerProxy{}
}
</code></pre><p>당연히 <em><code>*interface</code> = <code>*struct</code></em> 대입이 될 거라 생각했지만 컴파일러는 제게 에러 메시지 만을 남겼습니다.</p><blockquote><p>Cannot use &lsquo;NewGccCompilerProxy()&rsquo; (type *GccCompilerProxy) as type *CompilerProxy in assignment</p></blockquote><p>저 컴파일 에러 메시지를 보고서 생각에 빠졌습니다. C#에서도 <code>ref</code> 키워드를 이용할 때 <code>interface</code>와 <code>class</code> 두 타입 앞에 모두 붙였었는데 Go 에서는 뭔가 어떻게 다른 걸까라는 생각과 함께 <code>interface</code> 라는 키워드가 있는 여러 언어를 접해 보지 못했다는 것도 실감했습니다.</p><p><a href=https://tour.golang.org/>A Tour of Go</a> 와 Go 언어로 작성된 여러 코드들을 살펴보다가 <code>interface{}</code> 와 같이 사용하는 것을 보았습니다. 그 타입은 모든 타입과 매치되고 마치 <code>Object</code> 타입 처럼 보였다. 실제로 Go는 <a href=https://en.wikipedia.org/wiki/Reflection_(computer_programming)>Reflection</a>도 지원합니다. 그렇다면 Go 는 <a href=https://en.wikipedia.org/wiki/Java_(programming_language)>Java</a>나 <a href=https://en.wikipedia.org/wiki/C_Sharp_(programming_language)>C#</a> 처럼 VM위에서 돌아가는 걸까 라는 생각도 들었지만 <a href=https://golang.org/doc/faq#runtime>FAQ</a>를 읽어보면 그렇지는 않다고 말하고 있었습니다.</p><p>결국 Go 안에서 <code>interface</code> 관련 작업이 어떻게 이루어지는 알아보기로 했고 이 글을 통해 정리해보고자 합니다.</p><h2 id=interface-in-go>Interface in Go</h2><p>Go Spec 레퍼런스를 보면 <em>인터페이스는 메소드의 집합이다</em> 라고 말하고 있습니다. 자바나 기타 언어에서 와는 다르게 느껴집니다. 이는 <a href=https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming)>위키피디아 Protocol(OOP)</a> 문서에서도 말하듯 타언어에서는 명시적으로 인터페이스를 구현해야 한다에 가깝지만, Go에서는 인터페이스의 부분 집합인지를 검사하는 것에 가깝습니다. 인터페이스 검사에서 [Duck Typing] 방식을 채용하고 있기 때문입니다. 정적언어인 Go에서 이것이 어떻게 가능한 것일까요? Go 인터페이스가 어떻게 생겼고, 어떻게 다루지를 안다 면 쉽게 이해할 수 있습니다.</p><h2 id=go-interface-구조체-itab-만드는-법>Go Interface 구조체 (itab, 만드는 법)</h2><p>Go에서 인터페이스는 <code>iface</code>라는 이름의 구조체입니다. 타입을 설명하는 <code>itab</code>의 포인터와 실제 데이터를 가리키는 포인터로 이루어져 있습니다.</p><pre><code class=language-golang>type iface struct {
	tab  *itab
	data unsafe.Pointer
}
</code></pre><p><code>itab</code>은 해당 데이터가 어떤 인터페이스 타입이고 어떤 타입인지, 그리고 함수 테이블을 가지고 있습니다.</p><pre><code class=language-golang>// layout of Itab known to compilers
// allocated in non-garbage-collected memory
// Needs to be in sync with
// ../cmd/compile/internal/gc/reflect.go:/^func.dumptabs.
type itab struct {
	inter *interfacetype
	_type *_type
	hash  uint32 // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr // variable sized. fun[0]==0 means _type does not implement inter.
}
</code></pre><p>주석에서 볼 수 있듯이 코드 상에서 정적인 인터페이스 캐스팅이 있을 때 마다 <code>gc/subr.go#implements()</code> 메소드를 호출하여 캐스팅이 가능한지 검사를 합니다. 동시에 <code>itab</code> 을 생성 및 테이블에 등록합니다. 이 <code>itabTable</code>은 <em>.rodata</em> 섹션에 기록하고 실제 프로그램 실행되기 전에 가져오게 됩니다. 이와 관련된 초기화, 컴파일 과정은 다른 글에서 다뤄보도록 하겠습니다.</p><pre><code class=language-golang>func implements(t, iface *types.Type, m, samename **types.Field, ptr *int) bool {
	// *** codes ***
	if isdirectiface(t0) &amp;&amp; !iface.IsEmptyInterface() {
		itabname(t0, iface)
	}
	return true
}
</code></pre><p>위에서 볼 수 있듯이 비어있는 인터페이스, 즉 <code>interface{}</code>로의 변환은 <code>itab</code>을 생성하지 않습니다. 왜냐하면 <code>interface{}</code>의 경우 메소드를 가지지 않는 빈 인터페이스 이므ㅏ로 실제 데이터의 타입과 그 데이터를 가리키는 포인터만 가지고 있으면 충분합니다. 그래서 <code>eface</code>라는 구조체를 사용합니다.</p><pre><code class=language-golang>// runtime/runtime2.go
type eface struct {
	_type *_type
	data  unsafe.Pointer
}
</code></pre><p>변환할때는 런타임시에 <code>runtime.convT64</code>, <code>runtime.assertE2I</code> 와 같은 *runtime/runtime2.go*에 작성되어 있는 함수들을 사용합니다. 어떤 함수들을 호출하게 바뀌는 지는 컴파일 과정중 만드는 SSA를 보면 쉽게 알 수 있습니다.</p><pre><code>$ GOSSAFUNC=func go build test.go
# command-line-arguments
dumped SSA to ./ssa.html
</code></pre><p><img src=https://user-images.githubusercontent.com/26626194/76146532-dc173e00-60d6-11ea-973a-e5567378e15a.png alt=image></p><h2 id=인터페이스-메소드-호출>인터페이스 메소드 호출</h2><p>인터페이스에서 메소드를 호출 하는 것은 <code>itab</code> 구조체의 필드 <code>fun</code> 가상 테이블에서 함수 포인터를 가져와서 실행합니다. 이 때문에 어쩔 수 없이 성능 저하가 발생합니다. 하지만 CPU 캐시 히트를 맞히면 직접 호출과 다르지 않은 속도를 기대할 수도 있습니다. 이 부분은 <a href=https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md>다음 글</a>에서 잘 설명되어 있기 때문에 생략하겠습니다.</p><h2 id=마무리>마무리</h2><p>Golang에서 vm 없이 동적 타입을 어떻게 다루는지, interface가 어떻게 생겼는지, 컴파일러 과정 및 컴파일러 내부 코드 구조를 알 수 있어서 좋았습니다. 앞으로 go로 작성할 때 성능을 신경써야 하는 부분이 있다면 이런 캐시히트도 봐야겠구나 라는 생각이 들었습니다.</p><h2 id=reference>Reference</h2><ul><li><a href=https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md>https://github.com/teh-cmc/go-internals/blob/master/chapter2_interfaces/README.md</a></li><li><a href=https://research.swtch.com/interfaces>https://research.swtch.com/interfaces</a></li><li><a href=http://www.programmersought.com/article/16341600537/>http://www.programmersought.com/article/16341600537/</a></li><li><a href=https://eli.thegreenplace.net/2019/go-compiler-internals-adding-a-new-statement-to-go-part-1/>https://eli.thegreenplace.net/2019/go-compiler-internals-adding-a-new-statement-to-go-part-1/</a></li></ul></div><div class=post-footer></div></article></main></body></html>